diff --git a/src/main.rs b/src/main.rs
index f5eb27b..dd8e21d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,19 +5,22 @@ use vulkano::VulkanLibrary;
 use vulkano::device::QueueFlags;
 use vulkano::device::physical::{PhysicalDevice, PhysicalDeviceType};
 use vulkano::instance::{Instance, InstanceCreateFlags, InstanceCreateInfo};
-use winit::event::{Event, WindowEvent};
-use winit::event_loop::{ControlFlow, EventLoop};
-use winit::window::WindowBuilder;
+use winit::application::ApplicationHandler;
+use winit::event::WindowEvent;
+use winit::event_loop::{ActiveEventLoop, ControlFlow, EventLoop};
+use winit::window::{Window, WindowId};
 
 // Our main application struct
-struct VulkanApp {
+struct GameApp {
+    #[allow(unused)]
     instance: Arc<Instance>,
+    #[allow(unused)]
     physical_device: Arc<PhysicalDevice>,
-    // We will add more here soon: Window, EventLoop, Logical Device, Queue, etc.
+    window: Option<Window>, // We will add more here soon: Window, EventLoop, Logical Device, Queue, etc.
 }
 
-impl VulkanApp {
-    pub fn new(event_loop: &EventLoop<()>) -> Self {
+impl GameApp {
+    pub fn new() -> Self {
         // --- Instance Creation ---
         let library = VulkanLibrary::new().expect("no local Vulkan library/DLL");
         // In the future, we'll need extensions for windowing. For now, this is fine.
@@ -58,28 +61,46 @@ impl VulkanApp {
         Self {
             instance,
             physical_device,
+            window: None,
         }
     }
+}
 
-    pub fn run(self, event_loop: EventLoop<()>) {
-        // For now, let's just create a window and a basic event loop.
-        // We are not drawing anything yet.
-        let window = Arc::new(WindowBuilder::new().build(&event_loop).unwrap());
+impl ApplicationHandler for GameApp {
+    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
+        self.window = Some(
+            event_loop
+                .create_window(Window::default_attributes())
+                .unwrap(),
+        ); // We can only make a window while app is running
+    }
 
-        event_loop.run(|event, _, control_flow| match event {
-            Event::WindowEvent {
-                event: WindowEvent::CloseRequested,
-                ..
-            } => {
-                *control_flow = ControlFlow::Exit;
+    fn window_event(&mut self, event_loop: &ActiveEventLoop, _: WindowId, event: WindowEvent) {
+        match event {
+            WindowEvent::CloseRequested => {
+                println!("The close button was pressed; stopping");
+                event_loop.exit();
+            }
+            WindowEvent::RedrawRequested => {
+                self.window.as_ref().unwrap().request_redraw();
             }
             _ => (),
-        });
+        }
     }
 }
 
 fn main() {
-    let event_loop = EventLoop::new();
-    let app = VulkanApp::new(&event_loop);
-    app.run(event_loop);
+    let event_loop = EventLoop::new().unwrap();
+
+    // ControlFlow::Poll continuously runs the event loop, even if the OS hasn't
+    // dispatched any events. This is ideal for games and similar applications.
+    event_loop.set_control_flow(ControlFlow::Poll);
+
+    // ControlFlow::Wait pauses the event loop if no events are available to process.
+    // This is ideal for non-game applications that only update in response to user
+    // input, and uses significantly less power/CPU time than ControlFlow::Poll.
+    event_loop.set_control_flow(ControlFlow::Wait);
+
+    let mut app = GameApp::new();
+    event_loop.run_app(&mut app).unwrap();
 }
